@using System.Security.Cryptography.X509Certificates
@model IEnumerable<Warrior>

<body class="battlefield">
<div class="container bg-black text-white">
    @{
        Warrior w1;
        Warrior w2;
        int w1MaxHp;
        int w2MaxHp;
        <div class="row">
            <div class="col">
                @foreach (var warrior in Model)
                {
                    if (warrior.UserId == User.Identity.ToString())
                    {
                        w1 = warrior;
                        w1MaxHp = warrior.Hp;
                        <img src="@w1.ImageLink" width="200" height="148"/>
                        <div>@w1.WarriorName</div>
                        <div>@w1.Hp / @w1MaxHp</div>
                    }
                }
            </div>
            <div class="col">
                @foreach (var warrior in Model)
                {
                    if (warrior.UserId != User.Identity.ToString())
                    {
                        w2 = warrior;
                        w2MaxHp = warrior.Hp;
                        <img src="@w2.ImageLink" width="200" height="148"/>
                        <div>@w2.WarriorName</div>
                        <div>@w2.Hp / @w2MaxHp</div>
                    }
                }
            </div>
        </div>

        @functions {

            public void SimulateSetAndBattle(Warrior pos1, Warrior pos2)
            {
                var random = new Random();

                var battle = new List<Warrior>();
                battle.Add(pos1);
                battle.Add(pos2);
                int attackRoll;
                int damageRoll;

                int count = 0;
                int count2 = 1;

                do
                {
                    var attacker = battle[count % 2];
                    var defender = battle[count2 % 2];
                    if (attacker.Hp >= 0)
                    {
                        attackRoll = random.Next(20) + 1 + battle[count % 2].AttackMod;
                        if (attackRoll >= battle[count2 % 2].Defense)
                        {
                            if (attackRoll == 20 + battle[count % 2].AttackMod)
                            {
                                //code for delaying message
                                damageRoll = random.Next(attacker.DieSide) * attacker.Crit + attacker.AttackMod;
                                defender.Hp -= damageRoll;
                                <div>@DisplayBattle(attacker, defender, damageRoll)</div>
                            }
                            else
                            {
                                //code for delaying message
                                damageRoll = damageRoll = random.Next(attacker.DieSide) * attacker.AttackMod;
                                defender.Hp -= damageRoll;
                                <div>@DisplayBattle(attacker, defender, damageRoll)</div>
                            }
                        }
                    }

                    count++;
                    count2++;
                } while (battle[0].Hp > 0 && battle[1].Hp > 0);
            }

            public string DisplayBattle(Warrior war1, Warrior war2, int dmg)
            {
                var result = war1.WarriorName + " attacked " + war2.WarriorName + " and dealt " + dmg + " damage. " + war2.WarriorName + " has " + war2.Hp + " left.";
                return result;
            }

            //Create a function for printing the winner

        }

        <div class="row bg-text">
        <div class="col">
        </div>
    </div>
    }
</div>

</body>